<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Read junctionSeq count files</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.3/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.3/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.3/languages/r.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</head><body>

<table width="100%" summary="page for readJunctionSeqCounts {JunctionSeq}"><tr><td>readJunctionSeqCounts {JunctionSeq}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>
Read junctionSeq count files
</h2>

<h3>Description</h3>

<p>This function loads read-count data (usually produced by QoRTs) and 
compiles them into a <code>JunctionSeqCountSet</code> object.
</p>
<p>This function is called internally by the <code><a href="runJunctionSeqAnalyses.html">runJunctionSeqAnalyses</a></code> 
function, and thus for most purposes users should not need to call this
function directly. It may be useful to advanced users performing non-standard
analyses.
</p>


<h3>Usage</h3>

<pre>
readJunctionSeqCounts(countfiles, countdata,
    samplenames,  design,
    flat.gff.file, 
    test.formula1 = formula(~ sample + countbin + condition : countbin),
    analysis.type = c("junctionsAndExons","junctionsOnly","exonsOnly"),
    nCores = 1,
    use.exons, use.junctions, 
    use.known.junctions = TRUE, use.novel.junctions = TRUE,
    use.multigene.aggregates = FALSE,
    gene.names,
    verbose = TRUE,
    method.countVectors = c("geneLevelCounts","sumOfAllBinsForGene","sumOfAllBinsOfSameTypeForGene")
)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>countfiles</code></td>
<td>

<p>Character vector. The filenames of the count files generated by QoRTs. The counts must all
be generated using equivalent QoRTs parameters. The strandedness must be the same, as well
as the inclusion of novel junctions.
</p>
</td></tr>
<tr valign="top"><td><code>countdata</code></td>
<td>

<p>List. An alternative parameterization. Instead of supplying count files using the 
countfiles parameter, you can pass a list of data frames, one for each sample. 
Each data frame should contain two columns: the first should be the feature id 
and the second should be the counts. This list must have the same length as 
the samplenames parameter.
</p>
</td></tr>
<tr valign="top"><td><code>samplenames</code></td>
<td>

<p>Character vector. A vector of full sample names, in the same order as the countfiles parameter. 
</p>
</td></tr>
<tr valign="top"><td><code>design</code></td>
<td>

<p>A data frame containing the condition variable and all desired covariates. All variables should be
factors.
</p>
</td></tr>
<tr valign="top"><td><code>flat.gff.file</code></td>
<td>

<p>Character string. The filename of the &quot;flat&quot; gff annotation file. Can be gzip-compressed. 
This &quot;flat&quot; gff file must be produced by the QoRTs jar utility using the makeFlatGtf or 
mergeNovelSplices functions (depending on whether inclusion of novel splice junctions is desired).
</p>
<p>NOTE: This option is technically optional, but strongly recommended. If it is not included, then 
attempts to plot the results will crash unless (non-default) options are used to deactivate the 
plotting of genomic coordinates and transcript information
</p>
</td></tr>
<tr valign="top"><td><code>test.formula1</code></td>
<td>

<p>For advanced users. The base formula for the alternate hypothesis model used in the hypothesis tests.
</p>
<p>NOTE: the biological condition to be tested must be named &quot;condition&quot;.
</p>
</td></tr>
<tr valign="top"><td><code>analysis.type</code></td>
<td>

<p>Character string. One of &quot;junctionsAndExons&quot;, &quot;junctionsOnly&quot;, or &quot;exonsOnly&quot;. This parameter determines 
what type of analysis is to be performed. By default JunctionSeq tests both splice junction 
loci and exonic regions for differential usage (a &quot;hybrid&quot; analysis). This parameter
can be used to limit analyses specifically to either splice junction loci or exonic regions.
</p>
</td></tr>
<tr valign="top"><td><code>nCores</code></td>
<td>

<p>The number of cores to use. Note that multicore functionality may not be available on all platforms.
</p>
</td></tr>
<tr valign="top"><td><code>use.exons</code></td>
<td>

<p>Logical value. This is an alternate parameterization of the <code>analysis.type</code> parameter. 
If <code>TRUE</code>, then exonic region loci will be included in the analyses and will be tested for 
differential usage. If this parameter is set, then parameter <code>use.junctions</code> must also be set.
</p>
</td></tr>
<tr valign="top"><td><code>use.junctions</code></td>
<td>

<p>Logical value. This is an alternate parameterization of the <code>analysis.type</code> parameter. 
If <code>TRUE</code>, then splice junction loci will be included in the analyses and will be tested for 
differential usage. If this parameter is set, then parameter <code>use.exons</code> must also be set.
</p>
</td></tr>
<tr valign="top"><td><code>use.known.junctions</code></td>
<td>

<p>Logical value. If <code>TRUE</code>, then known splice junctions will not be filtered out prior to analysis. Note: this is overidden if use.junctions is <code>FALSE</code> or if <code>analysis.type</code> is set to &quot;exonsOnly&quot;.
</p>
</td></tr>
<tr valign="top"><td><code>use.novel.junctions</code></td>
<td>

<p>Logical value. If <code>TRUE</code>, then novel splice junctions will not be filtered out prior to analysis. Note: this is overidden if use.junctions is <code>FALSE</code> or if <code>analysis.type</code> is set to &quot;exonsOnly&quot;.
</p>
</td></tr>
<tr valign="top"><td><code>use.multigene.aggregates</code></td>
<td>

<p>Logical value. Whether to attempt to test &quot;aggregate genes&quot; which consist of multiple genes that overlap with one another. Note that inclusion of aggregate genes may affect the false discovery rate, since by their very nature aggregate genes will often show differential splice junction usage, as the two genes will often be regulated independently.
</p>
</td></tr>
<tr valign="top"><td><code>gene.names</code></td>
<td>

<p>data.frame. This optional parameter can be used to decoder the gene id's used in the actual analysis into gene symbols or gene names for general readability.
This must be a data.frame with two columns of character strings. The first must be the gene ID's, and the second must be the gene names (as you wish them to appear in the plots). Genes
are allowed to have multiple gene names, in which case they will be separated by commas.
The gene names will be used in the plots and figures.
</p>
</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>
<p>if TRUE, send debugging and progress messages to the console / stdout.</p>
</td></tr>
<tr valign="top"><td><code>method.countVectors</code></td>
<td>

<p>Character string. Can be used to apply alternative methodologies or implementations. Intended for advanced users who have strong opinions about the underlying statistical methodologies.
</p>
<p>Determines the type of count vectors to be used in the model framework. By default JunctionSeq compares the counts for a specific feature against the counts across the rest 
of the gene minus the counts for the specific feature. Alternatively, the sum of all other features on the gene can be used, like in DEXSeq. The advantage to the default JunctionSeq
behavior is that no read or read-pair is ever counted more than once in any model. Under DEXSeq, some reads may cover many exonic segments and thus be counted repeatedly.
</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A JunctionSeqCountSet.
</p>


<h3>Examples</h3>

<pre><code class="r">########################################
#Set up example data:
decoder.file &lt;- system.file(&quot;extdata/annoFiles/decoder.bySample.txt&quot;,package=&quot;JctSeqExData2&quot;);
decoder &lt;- read.table(decoder.file,
                      header=TRUE,
                      stringsAsFactors=FALSE);
gff.file &lt;- system.file(&quot;extdata/cts/withNovel.forJunctionSeq.gff.gz&quot;,package=&quot;JctSeqExData2&quot;);
countFiles &lt;- system.file(paste0(&quot;extdata/cts/&quot;,
                 decoder$sample.ID,
                 &quot;/QC.spliceJunctionAndExonCounts.withNovel.forJunctionSeq.txt.gz&quot;),
                 package=&quot;JctSeqExData2&quot;);
########################################
#Advanced Analysis:

#Make a &quot;design&quot; dataframe:
design &lt;- data.frame(condition = factor(decoder$group.ID));
#Read the QoRTs counts.
jscs = readJunctionSeqCounts(countfiles = countFiles,
           samplenames = decoder$sample.ID,
           design = design,
           flat.gff.file = gff.file
);
</code></pre>

<pre><code>## -&gt; STARTING readJunctionSeqCounts (Wed Nov 11 20:24:28 2015)
## ---&gt; RJSC: samplenames: SAMP1,SAMP2,SAMP3,SAMP4,SAMP5,SAMP6
## ---&gt; RJSC: flat.gff.file: /home/hartleys/R/R3.2.2/lib/JctSeqExData2/extdata/cts/withNovel.forJunctionSeq.gff.gz
## ---&gt; RJSC: use.exons:TRUE
## ---&gt; RJSC: use.junctions:TRUE
## ---&gt; RJSC: use.novel.junctions:TRUE
## ---&gt; File read complete.
## ---&gt; Extracted counts. Found 16160 features so far.
## ---&gt; Extracted gene-level counts. Found: 1053 genes and aggregate-genes.
## ---&gt; Removed gene features. Found: 15107 features to be included so far.
## ---&gt; Note: 256 counting bins are from 256 multigene aggregates (ie. overlapping genes).
## ---&gt; Removed multigene-aggregate features. Found: 14851 features to be included so far.
## ---&gt; Final feature count: 14851 features to be included in the analysis.
## ---&gt; Extracted feature counts.
## ---&gt; counts complete.
## -----&gt; reading annotation...
## -----&gt; formatting annotation...
## -----&gt; initial generation...
## -----&gt; creating jscs...
## -----&gt; generating count vectors... (Wed Nov 11 20:24:31 2015)
##     getAllJunctionSeqCountVectors: dim(counts) = 14851,6 (Wed Nov 11 20:24:31 2015)
##     getAllJunctionSeqCountVectors: dim(gct) = 1053,6
##     getAllJunctionSeqCountVectors: out generated. dim = 14851,12 (Wed Nov 11 20:24:32 2015)
## -----&gt; count vectors generated (Wed Nov 11 20:24:32 2015)
## -----&gt; generating DESeqDataSet... (Wed Nov 11 20:24:32 2015)
## -----&gt; DESeqDataSet generated (Wed Nov 11 20:24:32 2015)
</code></pre>


<hr /><div style="text-align: center;">[Package <em>JunctionSeq</em> version 0.6.1 <a href="00Index.html">Index</a>]</div>
</body></html>
