
R version 3.2.2 (2015-08-14) -- "Fire Safety"
Copyright (C) 2015 The R Foundation for Statistical Computing
Platform: i386-w64-mingw32/i386 (32-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "JunctionSeq"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> options(pager = "console")
> library('JunctionSeq')
Loading required package: SummarizedExperiment
Loading required package: GenomicRanges
Loading required package: BiocGenerics
Loading required package: parallel

Attaching package: 'BiocGenerics'

The following objects are masked from 'package:parallel':

    clusterApply, clusterApplyLB, clusterCall, clusterEvalQ,
    clusterExport, clusterMap, parApply, parCapply, parLapply,
    parLapplyLB, parRapply, parSapply, parSapplyLB

The following objects are masked from 'package:stats':

    IQR, mad, xtabs

The following objects are masked from 'package:base':

    Filter, Find, Map, Position, Reduce, anyDuplicated, append,
    as.data.frame, as.vector, cbind, colnames, do.call, duplicated,
    eval, evalq, get, grep, grepl, intersect, is.unsorted, lapply,
    lengths, mapply, match, mget, order, paste, pmax, pmax.int, pmin,
    pmin.int, rank, rbind, rownames, sapply, setdiff, sort, table,
    tapply, union, unique, unlist, unsplit

Loading required package: S4Vectors
Loading required package: stats4
Loading required package: IRanges
Loading required package: GenomeInfoDb
Loading required package: Biobase
Welcome to Bioconductor

    Vignettes contain introductory material; view with
    'browseVignettes()'. To cite Bioconductor, see
    'citation("Biobase")', and for packages 'citation("pkgname")'.

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("JunctionSeqCountSet-class")
> ### * JunctionSeqCountSet-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: JunctionSeqCountSet-class
> ### Title: Class '"JunctionSeqCountSet"'
> ### Aliases: JunctionSeqCountSet-class JunctionSeqCountSet
> ### Keywords: classes
> 
> ### ** Examples
> 
> showClass("JunctionSeqCountSet")
Class "JunctionSeqCountSet" [package "JunctionSeq"]

Slots:
                                                            
Name:               designColumns               dispFitCoefs
Class:                  character                    numeric
                                                            
Name:                    fittedMu           dispFunctionType
Class:                     matrix                       list
                                                            
Name:                dispFunction            dispFunctionJct
Class:                   function                   function
                                                            
Name:            dispFunctionExon                   formulas
Class:                   function                       list
                                                            
Name:              annotationFile              geneCountData
Class:                  character                     matrix
                                                            
Name:                countVectors             altSizeFactors
Class:                     matrix                 data.frame
                                                            
Name:           plottingEstimates       plottingEstimatesVST
Class:                       list                       list
                                                            
Name:  geneLevelPlottingEstimates  modelFitForHypothesisTest
Class:                       list                       list
                                                            
Name:       modelFitForEffectSize                flatGffData
Class:                       list                 data.frame
                                                            
Name:             flatGffGeneData               analysisType
Class:                       list                  character
                                                            
Name:                DESeqDataSet    modelCoefficientsSample
Class:               DESeqDataSet                       list
                                                            
Name:       modelCoefficientsGene                  assayData
Class:                       list                  AssayData
                                                            
Name:                   phenoData                featureData
Class:         AnnotatedDataFrame         AnnotatedDataFrame
                                                            
Name:              experimentData                 annotation
Class:                      MIAxE                  character
                                                            
Name:                protocolData          .__classVersion__
Class:         AnnotatedDataFrame                   Versions

Extends: 
Class "eSet", directly
Class "VersionedBiobase", by class "eSet", distance 2
Class "Versioned", by class "eSet", distance 3
> 
> 
> 
> cleanEx()
> nameEx("buildAllPlots")
> ### * buildAllPlots
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: buildAllPlots
> ### Title: Create and save a full battery of JunctionSeq expression plots.
> ### Aliases: buildAllPlots
> 
> ### ** Examples
> 
> 
> data(exampleDataSet,package="JctSeqExData2");
> buildAllPlots(jscs);
> buildAllPlots: Found 5 genes with at least one significant exon, at adjusted-p-value threshold 0.01
> buildAllPlots: Starting plotting...
Warning in dir.create(outfile.prefix) : '.' already exists
> buildAllPlots: Generating Dispersion Plot
     abundance ranges from 0.145790229164005 to 5483.2391226577
     dispersion ranges from 1.94121702327417e-06 to 2.08796433211328
     Plotting dispersions from 2.61759974125911e-05 to 2.08796433211328
> buildAllPlots: Generating MA-Plot (log2FC(CTRL/CASE))
> buildAllPlots: Writing HTML results index.
   Copying default css stylesheet.
   Writing html index. Wed Nov 18 17:28:09 2015
   Writing formula data. Wed Nov 18 17:28:09 2015
   Writing methods data. Wed Nov 18 17:28:09 2015
   Writing sample data. Wed Nov 18 17:28:09 2015
   Writing dispersion data. Wed Nov 18 17:28:09 2015
   Writing summary plots. Wed Nov 18 17:28:09 2015
   Compiling data table. Wed Nov 18 17:28:09 2015
   Writing data table. Wed Nov 18 17:28:09 2015
   Html index complete. Wed Nov 18 17:28:09 2015
   Writing pages. Wed Nov 18 17:28:09 2015
   Finished all html files. Wed Nov 18 17:28:09 2015
> buildAllPlots: Finished writing HTML results index.
> buildAllPlots: starting geneID: ENSRNOG00000008079 (1 of 5)
starting buildAllPlotsForGene() for geneID: ENSRNOG00000008079
Starting nested heights...
> pJSRfG(): ENSRNOG00000008079, plot.type: expr (with TX)
> pJSRfG(): ENSRNOG00000008079, plot.type: expr
> pJSRfG(): ENSRNOG00000008079, plot.type: normCounts (with TX)
> pJSRfG(): ENSRNOG00000008079, plot.type: normCounts
> pJSRfG(): ENSRNOG00000008079, plot.type: rExpr (with TX)
> pJSRfG(): ENSRNOG00000008079, plot.type: rExpr
> buildAllPlots: starting geneID: ENSRNOG00000009281 (2 of 5)
starting buildAllPlotsForGene() for geneID: ENSRNOG00000009281
Starting nested heights...
> pJSRfG(): ENSRNOG00000009281, plot.type: expr (with TX)
> pJSRfG(): ENSRNOG00000009281, plot.type: expr
> pJSRfG(): ENSRNOG00000009281, plot.type: normCounts (with TX)
> pJSRfG(): ENSRNOG00000009281, plot.type: normCounts
> pJSRfG(): ENSRNOG00000009281, plot.type: rExpr (with TX)
> pJSRfG(): ENSRNOG00000009281, plot.type: rExpr
> buildAllPlots: starting geneID: ENSRNOG00000056944 (3 of 5)
starting buildAllPlotsForGene() for geneID: ENSRNOG00000056944
Starting nested heights...
> pJSRfG(): ENSRNOG00000056944, plot.type: expr (with TX)
> pJSRfG(): ENSRNOG00000056944, plot.type: expr
> pJSRfG(): ENSRNOG00000056944, plot.type: normCounts (with TX)
> pJSRfG(): ENSRNOG00000056944, plot.type: normCounts
> pJSRfG(): ENSRNOG00000056944, plot.type: rExpr (with TX)
> pJSRfG(): ENSRNOG00000056944, plot.type: rExpr
> buildAllPlots: starting geneID: ENSRNOG00000004621 (4 of 5)
starting buildAllPlotsForGene() for geneID: ENSRNOG00000004621
Starting nested heights...
> pJSRfG(): ENSRNOG00000004621, plot.type: expr (with TX)
> pJSRfG(): ENSRNOG00000004621, plot.type: expr
> pJSRfG(): ENSRNOG00000004621, plot.type: normCounts (with TX)
> pJSRfG(): ENSRNOG00000004621, plot.type: normCounts
> pJSRfG(): ENSRNOG00000004621, plot.type: rExpr (with TX)
> pJSRfG(): ENSRNOG00000004621, plot.type: rExpr
> buildAllPlots: starting geneID: ENSRNOG00000002210 (5 of 5)
starting buildAllPlotsForGene() for geneID: ENSRNOG00000002210
Starting nested heights...
> pJSRfG(): ENSRNOG00000002210, plot.type: expr (with TX)
> pJSRfG(): ENSRNOG00000002210, plot.type: expr
> pJSRfG(): ENSRNOG00000002210, plot.type: normCounts (with TX)
> pJSRfG(): ENSRNOG00000002210, plot.type: normCounts
> pJSRfG(): ENSRNOG00000002210, plot.type: rExpr (with TX)
> pJSRfG(): ENSRNOG00000002210, plot.type: rExpr
> buildAllPlots: Plotting complete.
> buildAllPlots: Plotting and data writing complete.
> 
> ## Not run: 
> ##D ########################################
> ##D #Set up example data:
> ##D decoder.file <- system.file("extdata/annoFiles/decoder.bySample.txt",package="JctSeqExData2");
> ##D decoder <- read.table(decoder.file,
> ##D                       header=T,
> ##D                       stringsAsFactors=F);
> ##D gff.file <- system.file("extdata/cts/withNovel.forJunctionSeq.gff.gz",package="JctSeqExData2");
> ##D countFiles <- system.file(paste0("extdata/cts/",
> ##D                  decoder$sample.ID,
> ##D                  "/QC.spliceJunctionAndExonCounts.withNovel.forJunctionSeq.txt.gz"),
> ##D                  package="JctSeqExData2");
> ##D ########################################
> ##D #Run example analysis:
> ##D jscs <- runJunctionSeqAnalyses(sample.files = countFiles,
> ##D            sample.names = decoder$sample.ID,
> ##D            condition=factor(decoder$group.ID),
> ##D            flat.gff.file = gff.file,
> ##D            analysis.type = "junctionsAndExons"
> ##D );
> ##D ########################################
> ##D 
> ##D #Generate all plots and the html index
> ##D #   Save them as pngs to the current directory:
> ##D buildAllPlots(jscs);
> ##D 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("buildAllPlotsForGene")
> ### * buildAllPlotsForGene
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: buildAllPlotsForGene
> ### Title: Create and save one or more JunctionSeq expression plots.
> ### Aliases: buildAllPlotsForGene
> 
> ### ** Examples
> 
> data(exampleDataSet,package="JctSeqExData2");
> buildAllPlotsForGene(geneID = "ENSRNOG00000009281", jscs);
starting buildAllPlotsForGene() for geneID: ENSRNOG00000009281
Starting nested heights...
> pJSRfG(): ENSRNOG00000009281, plot.type: expr (with TX)
> pJSRfG(): ENSRNOG00000009281, plot.type: expr
> pJSRfG(): ENSRNOG00000009281, plot.type: normCounts (with TX)
> pJSRfG(): ENSRNOG00000009281, plot.type: normCounts
> pJSRfG(): ENSRNOG00000009281, plot.type: rExpr (with TX)
> pJSRfG(): ENSRNOG00000009281, plot.type: rExpr
> 
> ## Not run: 
> ##D ########################################
> ##D #Set up example data:
> ##D decoder.file <- system.file("extdata/annoFiles/decoder.bySample.txt",package="JctSeqExData2");
> ##D decoder <- read.table(decoder.file,
> ##D                       header=T,
> ##D                       stringsAsFactors=F);
> ##D gff.file <- system.file("extdata/cts/withNovel.forJunctionSeq.gff.gz",package="JctSeqExData2");
> ##D countFiles <- system.file(paste0("extdata/cts/",
> ##D                  decoder$sample.ID,
> ##D                  "/QC.spliceJunctionAndExonCounts.withNovel.forJunctionSeq.txt.gz"),
> ##D                  package="JctSeqExData2");
> ##D ######################
> ##D #Run example analysis:
> ##D jscs <- runJunctionSeqAnalyses(sample.files = countFiles,
> ##D            sample.names = decoder$sample.ID,
> ##D            condition=factor(decoder$group.ID),
> ##D            flat.gff.file = gff.file,
> ##D            analysis.type = "junctionsAndExons"
> ##D );
> ##D ########################################
> ##D 
> ##D #Generate several related plots for the selected gene:
> ##D buildAllPlotsForGene(geneID = "ENSRNOG00000009281", jscs);
> ##D 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("defaultColorList")
> ### * defaultColorList
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: defaultColorList
> ### Title: JunctionSeq Color Parameters
> ### Aliases: JUNCTIONSEQ.DEFAULT.COLOR.LIST defaultColorList
> ###   junctionSeqColors
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(exampleDataSet,package="JctSeqExData2");
> 
> #Set a few alternative colors:
> buildAllPlotsForGene(geneID = "ENSRNOG00000009281", jscs, 
+                      outfile.prefix = "./oddColors.",
+                      colorList = list(SIG.FEATURE.COLOR = "red",
+                                       SIG.FEATURE.FILL.COLOR = "green",
+                                       NOSIG.FEATURE.FILL.COLOR = "blue"
+                                       ));
starting buildAllPlotsForGene() for geneID: ENSRNOG00000009281
Starting nested heights...
> pJSRfG(): ENSRNOG00000009281, plot.type: expr (with TX)
> pJSRfG(): ENSRNOG00000009281, plot.type: expr
> pJSRfG(): ENSRNOG00000009281, plot.type: normCounts (with TX)
> pJSRfG(): ENSRNOG00000009281, plot.type: normCounts
> pJSRfG(): ENSRNOG00000009281, plot.type: rExpr (with TX)
> pJSRfG(): ENSRNOG00000009281, plot.type: rExpr
> 
> 
> 
> cleanEx()
> nameEx("estimateEffectSizes")
> ### * estimateEffectSizes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: estimateEffectSizes
> ### Title: Estimate Effect Sizes, parameter estimates, etc.
> ### Aliases: estimateEffectSizes
> 
> ### ** Examples
> 
> data(exampleDataSet,package="JctSeqExData2");
> jscs <- estimateEffectSizes(jscs);
-------> estimateEffectSizes: (Calculating effect size and predicted values for feature 1000 of 1516)(Wed Nov 18 17:29:05 2015)
-------> estimateEffectSizes: Estimating gene-level expression.
-------> estimateEffectSizes: (Calculating gene-level effect size and predicted values for gene 100 of 117)(Wed Nov 18 17:29:06 2015)
-------> estimateEffectSizes: Starting gene-wise p-adjust. (Wed Nov 18 17:29:06 2015)
-------> estimateEffectSizes: Finished gene-wise p-adjust. (Wed Nov 18 17:29:06 2015)
> 
> ## Not run: 
> ##D #Full example (from scratch):
> ##D 
> ##D ########################################
> ##D #Set up example data:
> ##D decoder.file <- system.file("extdata/annoFiles/decoder.bySample.txt",package="JctSeqExData2");
> ##D decoder <- read.table(decoder.file,
> ##D                       header=T,
> ##D                       stringsAsFactors=F);
> ##D gff.file <- system.file("extdata/cts/withNovel.forJunctionSeq.gff.gz",package="JctSeqExData2");
> ##D countFiles <- system.file(paste0("extdata/cts/",
> ##D                  decoder$sample.ID,
> ##D                  "/QC.spliceJunctionAndExonCounts.withNovel.forJunctionSeq.txt.gz"),
> ##D                  package="JctSeqExData2");
> ##D ########################################
> ##D #Advanced Analysis:
> ##D 
> ##D #Make a "design" dataframe:
> ##D design <- data.frame(condition = factor(decoder$group.ID));
> ##D #Read the QoRTs counts.
> ##D jscs = readJunctionSeqCounts(countfiles = countFiles,
> ##D            samplenames = decoder$sample.ID,
> ##D            design = design,
> ##D            flat.gff.file = gff.file
> ##D );
> ##D #Generate the size factors and load them into the JunctionSeqCountSet:
> ##D jscs <- estimateJunctionSeqSizeFactors(jscs);
> ##D #Estimate feature-specific dispersions:
> ##D jscs <- estimateJunctionSeqDispersions(jscs);
> ##D #Fit dispersion function and estimate MAP dispersion:
> ##D jscs <- fitJunctionSeqDispersionFunction(jscs);
> ##D #Test for differential usage:
> ##D jscs <- testForDiffUsage(jscs);
> ##D #Estimate effect sizes and expression estimates:
> ##D jscs <- estimateEffectSizes( jscs);
> ##D 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("estimateJunctionSeqDispersions")
> ### * estimateJunctionSeqDispersions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: estimateJunctionSeqDispersions
> ### Title: JunctionSeq Dispersion Estimation
> ### Aliases: estimateJunctionSeqDispersions
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #Full example (from scratch):
> ##D ########################################
> ##D #Set up example data:
> ##D decoder.file <- system.file("extdata/annoFiles/decoder.bySample.txt",package="JctSeqExData2");
> ##D decoder <- read.table(decoder.file,
> ##D                       header=T,
> ##D                       stringsAsFactors=F);
> ##D gff.file <- system.file("extdata/cts/withNovel.forJunctionSeq.gff.gz",package="JctSeqExData2");
> ##D countFiles <- system.file(paste0("extdata/cts/",
> ##D                  decoder$sample.ID,
> ##D                  "/QC.spliceJunctionAndExonCounts.withNovel.forJunctionSeq.txt.gz"),
> ##D                  package="JctSeqExData2");
> ##D ########################################
> ##D #Advanced Analysis:
> ##D 
> ##D #Make a "design" dataframe:
> ##D design <- data.frame(condition = factor(decoder$group.ID));
> ##D #Read the QoRTs counts.
> ##D jscs = readJunctionSeqCounts(countfiles = countFiles,
> ##D            samplenames = decoder$sample.ID,
> ##D            design = design,
> ##D            flat.gff.file = gff.file
> ##D );
> ##D #Generate the size factors and load them into the JunctionSeqCountSet:
> ##D jscs <- estimateJunctionSeqSizeFactors(jscs);
> ##D #Estimate feature-specific dispersions:
> ##D jscs <- estimateJunctionSeqDispersions(jscs);
> ##D #Fit dispersion function and estimate MAP dispersion:
> ##D jscs <- fitJunctionSeqDispersionFunction(jscs);
> ##D #Test for differential usage:
> ##D jscs <- testForDiffUsage(jscs);
> ##D #Estimate effect sizes and expression estimates:
> ##D jscs <- estimateEffectSizes( jscs);
> ##D 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("estimateJunctionSeqSizeFactors")
> ### * estimateJunctionSeqSizeFactors
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: estimateJunctionSeqSizeFactors
> ### Title: Estimate Size Factors
> ### Aliases: estimateJunctionSeqSizeFactors writeSizeFactors
> 
> ### ** Examples
> 
> 
> data(exampleDataSet,package="JctSeqExData2");
> jscs <- estimateJunctionSeqSizeFactors(jscs);
> 
> ## Not run: 
> ##D ########################################
> ##D #Set up example data:
> ##D decoder.file <- system.file("extdata/annoFiles/decoder.bySample.txt",package="JctSeqExData2");
> ##D decoder <- read.table(decoder.file,
> ##D                       header=T,
> ##D                       stringsAsFactors=F);
> ##D gff.file <- system.file("extdata/cts/withNovel.forJunctionSeq.gff.gz",package="JctSeqExData2");
> ##D countFiles <- system.file(paste0("extdata/cts/",
> ##D                  decoder$sample.ID,
> ##D                  "/QC.spliceJunctionAndExonCounts.withNovel.forJunctionSeq.txt.gz"),
> ##D                  package="JctSeqExData2");
> ##D ########################################
> ##D #Advanced Analysis:
> ##D 
> ##D #Make a "design" dataframe:
> ##D design <- data.frame(condition = factor(decoder$group.ID));
> ##D #Read the QoRTs counts.
> ##D jscs = readJunctionSeqCounts(countfiles = countFiles,
> ##D            samplenames = decoder$sample.ID,
> ##D            design = design,
> ##D            flat.gff.file = gff.file
> ##D );
> ##D #Generate the size factors and load them into the JunctionSeqCountSet:
> ##D jscs <- estimateJunctionSeqSizeFactors(jscs);
> ##D #Estimate feature-specific dispersions:
> ##D jscs <- estimateJunctionSeqDispersions(jscs);
> ##D #Fit dispersion function and estimate MAP dispersion:
> ##D jscs <- fitJunctionSeqDispersionFunction(jscs);
> ##D #Test for differential usage:
> ##D jscs <- testForDiffUsage(jscs);
> ##D #Estimate effect sizes and expression estimates:
> ##D jscs <- estimateEffectSizes( jscs);
> ##D 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("fitJunctionSeqDispersionFunction")
> ### * fitJunctionSeqDispersionFunction
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fitJunctionSeqDispersionFunction
> ### Title: Fit Shared Dispersion Function
> ### Aliases: fitJunctionSeqDispersionFunction
> 
> ### ** Examples
> 
> data(exampleDataSet,package="JctSeqExData2");
> jscs <- fitJunctionSeqDispersionFunction(jscs);
> fitDispersionFunction() Starting (Wed Nov 18 17:29:06 2015)
>   (fitType = parametric)
>   (finalDispersionMethod = shrink)
>   (fitDispersionsForExonsAndJunctionsSeparately = TRUE)
min(means[useForFit], na.rm=T)=0.145790229164005
>    fdf: Fitting dispersions:
>       (Iteration 1) Parametric Dispersion Coefs: [0.00465281511379581,0.21833858566876]
>       (Iteration 2) Parametric Dispersion Coefs: [0.00253260913896325,0.233591354846304]
>       (FINAL) Parametric Dispersion Coefs: [0.00253247692869195,0.233595537310823]
>    fdf: Fitting dispersions of exons and junctions to separate fitted trends.
>    fdf: Fitting exon dispersions:
>       (Iteration 1) Parametric Dispersion Coefs: [0.00461337253078783,0.282542146211808]
>       (Iteration 2) Parametric Dispersion Coefs: [0.00192271455359532,0.299462126671736]
>       (Iteration 3) Parametric Dispersion Coefs: [0.00185198065165201,0.288367123706037]
>       (FINAL) Parametric Dispersion Coefs: [0.00185203762243627,0.288364370044811]
>    fdf: Fitting splice-junction dispersions:
>       (Iteration 1) Parametric Dispersion Coefs: [0.00388660231675665,0.179229887506683]
>       (Iteration 2) Parametric Dispersion Coefs: [0.00375522634365911,0.180626540822821]
>       (FINAL) Parametric Dispersion Coefs: [0.00375530334214227,0.180625053840781]
> fdf(): 'Shrinking' fitted and feature-specific dispersion estimates.
> fdf() Dispersion estimate failed for 0 out of 482 features.
> fitDispersionFunction() Done. (Wed Nov 18 17:29:06 2015)
> 
> ## Not run: 
> ##D #Full example (from scratch):
> ##D ########################################
> ##D #Set up example data:
> ##D decoder.file <- system.file("extdata/annoFiles/decoder.bySample.txt",package="JctSeqExData2");
> ##D decoder <- read.table(decoder.file,
> ##D                       header=T,
> ##D                       stringsAsFactors=F);
> ##D gff.file <- system.file("extdata/cts/withNovel.forJunctionSeq.gff.gz",package="JctSeqExData2");
> ##D countFiles <- system.file(paste0("extdata/cts/",
> ##D                  decoder$sample.ID,
> ##D                  "/QC.spliceJunctionAndExonCounts.withNovel.forJunctionSeq.txt.gz"),
> ##D                  package="JctSeqExData2");
> ##D ########################################
> ##D #Advanced Analysis:
> ##D 
> ##D #Make a "design" dataframe:
> ##D design <- data.frame(condition = factor(decoder$group.ID));
> ##D #Read the QoRTs counts.
> ##D jscs = readJunctionSeqCounts(countfiles = countFiles,
> ##D            samplenames = decoder$sample.ID,
> ##D            design = design,
> ##D            flat.gff.file = gff.file
> ##D );
> ##D #Generate the size factors and load them into the JunctionSeqCountSet:
> ##D jscs <- estimateJunctionSeqSizeFactors(jscs);
> ##D #Estimate feature-specific dispersions:
> ##D jscs <- estimateJunctionSeqDispersions(jscs);
> ##D #Fit dispersion function and estimate MAP dispersion:
> ##D jscs <- fitJunctionSeqDispersionFunction(jscs);
> ##D #Test for differential usage:
> ##D jscs <- testForDiffUsage(jscs);
> ##D #Estimate effect sizes and expression estimates:
> ##D jscs <- estimateEffectSizes( jscs);
> ##D 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("plotDispEsts")
> ### * plotDispEsts
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plotDispEsts
> ### Title: Plot Fitted and Test-wise Dispersion
> ### Aliases: plotDispEsts
> 
> ### ** Examples
> 
> data(exampleDataSet,package="JctSeqExData2");
> plotDispEsts(jscs);
     abundance ranges from 0.145790229164005 to 5483.2391226577
     dispersion ranges from 1.94121702327417e-06 to 2.08796433211328
     Plotting dispersions from 2.61759974125911e-05 to 2.08796433211328
> 
> ## Not run: 
> ##D ########################################
> ##D #Set up example data:
> ##D decoder.file <- system.file("extdata/annoFiles/decoder.bySample.txt",package="JctSeqExData2");
> ##D decoder <- read.table(decoder.file,
> ##D                       header=T,
> ##D                       stringsAsFactors=F);
> ##D gff.file <- system.file("extdata/cts/withNovel.forJunctionSeq.gff.gz",package="JctSeqExData2");
> ##D countFiles <- system.file(paste0("extdata/cts/",
> ##D                  decoder$sample.ID,
> ##D                  "/QC.spliceJunctionAndExonCounts.withNovel.forJunctionSeq.txt.gz"),
> ##D                  package="JctSeqExData2");
> ##D ######################
> ##D #Run example analysis:
> ##D jscs <- runJunctionSeqAnalyses(sample.files = countFiles,
> ##D            sample.names = decoder$sample.ID,
> ##D            condition=factor(decoder$group.ID),
> ##D            flat.gff.file = gff.file,
> ##D            analysis.type = "junctionsAndExons"
> ##D );
> ##D ########################################
> ##D 
> ##D #Plot dispersions:
> ##D plotDispEsts(jscs);
> ##D 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("plotJunctionSeqResultsForGene")
> ### * plotJunctionSeqResultsForGene
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plotJunctionSeqResultsForGene
> ### Title: Generate a JunctionSeq expression plot.
> ### Aliases: plotJunctionSeqResultsForGene
> 
> ### ** Examples
> 
> data(exampleDataSet,package="JctSeqExData2");
> 
> plotJunctionSeqResultsForGene(geneID = "ENSRNOG00000009281", jscs);
> pJSRfG(): ENSRNOG00000009281, plot.type: expr
Starting nested heights...
> 
> 
> ## Not run: 
> ##D ########################################
> ##D #Set up example data:
> ##D decoder.file <- system.file("extdata/annoFiles/decoder.bySample.txt",package="JctSeqExData2");
> ##D decoder <- read.table(decoder.file,
> ##D                       header=T,
> ##D                       stringsAsFactors=F);
> ##D gff.file <- system.file("extdata/cts/withNovel.forJunctionSeq.gff.gz",package="JctSeqExData2");
> ##D countFiles <- system.file(paste0("extdata/cts/",
> ##D                  decoder$sample.ID,
> ##D                  "/QC.spliceJunctionAndExonCounts.withNovel.forJunctionSeq.txt.gz"),
> ##D                  package="JctSeqExData2");
> ##D ######################
> ##D #Run example analysis:
> ##D jscs <- runJunctionSeqAnalyses(sample.files = countFiles,
> ##D            sample.names = decoder$sample.ID,
> ##D            condition=factor(decoder$group.ID),
> ##D            flat.gff.file = gff.file,
> ##D            analysis.type = "junctionsAndExons"
> ##D );
> ##D ########################################
> ##D 
> ##D #Make an expression plot for a given gene:
> ##D plotJunctionSeqResultsForGene(geneID = "ENSRNOG00000009281", jscs);
> ##D 
> ##D #Plot normalized read counts for a given gene:
> ##D plotJunctionSeqResultsForGene(geneID = "ENSRNOG00000009281", jscs,
> ##D                     plot.type = "normCounts");
> ##D 
> ##D #Plot relative expression for a given gene:
> ##D plotJunctionSeqResultsForGene(geneID = "ENSRNOG00000009281", jscs,
> ##D                     plot.type = "rExpr");
> ##D 
> ##D #Plot raw read counts for a given gene:
> ##D plotJunctionSeqResultsForGene(geneID = "ENSRNOG00000009281", jscs,
> ##D                     plot.type = "rawCounts");
> ##D 
> ##D #Same thing, but with isoforms shown:
> ##D plotJunctionSeqResultsForGene(geneID = "ENSRNOG00000009281", jscs,
> ##D                     plot.type = "rawCounts",
> ##D                     displayTranscripts = TRUE);
> ##D 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("plotMA")
> ### * plotMA
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plotMA
> ### Title: Generate a MA-Plot
> ### Aliases: plotMA
> 
> ### ** Examples
> 
> data(exampleDataSet,package="JctSeqExData2");
> plotMA(jscs);
> 
> 
> ## Not run: 
> ##D ########################################
> ##D #Set up example data:
> ##D decoder.file <- system.file("extdata/annoFiles/decoder.bySample.txt",package="JctSeqExData2");
> ##D decoder <- read.table(decoder.file,
> ##D                       header=T,
> ##D                       stringsAsFactors=F);
> ##D gff.file <- system.file("extdata/cts/withNovel.forJunctionSeq.gff.gz",package="JctSeqExData2");
> ##D countFiles <- system.file(paste0("extdata/cts/",
> ##D                  decoder$sample.ID,
> ##D                  "/QC.spliceJunctionAndExonCounts.withNovel.forJunctionSeq.txt.gz"),
> ##D                  package="JctSeqExData2");
> ##D ######################
> ##D #Run example analysis:
> ##D jscs <- runJunctionSeqAnalyses(sample.files = countFiles,
> ##D            sample.names = decoder$sample.ID,
> ##D            condition=factor(decoder$group.ID),
> ##D            flat.gff.file = gff.file,
> ##D            analysis.type = "junctionsAndExons"
> ##D );
> ##D ########################################
> ##D 
> ##D #Plot M-A:
> ##D plotMA(jscs);
> ##D 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("readAnnotationData")
> ### * readAnnotationData
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: readAnnotationData
> ### Title: Read junctionSeq annotation files produced by QoRTs.
> ### Aliases: readAnnotationData
> 
> ### ** Examples
> 
> gff.file <- system.file("extdata/cts/withNovel.forJunctionSeq.gff.gz",package="JctSeqExData2");
> 
> #Parse the GFF file:
> annoData <- readAnnotationData(gff.file);
> head(annoData);
              featureName featureType chrom  start    end strand
1 ENSRNOG00000050954:E001 exonic_part chr14 182677 183555      -
2 ENSRNOG00000050954:E002 exonic_part chr14 184706 184830      -
3 ENSRNOG00000050954:E003 exonic_part chr14 186228 186453      -
4 ENSRNOG00000050954:E004 exonic_part chr14 189145 189973      -
5 ENSRNOG00000050954:E005 exonic_part chr14 190012 190189      -
6 ENSRNOG00000050954:E006 exonic_part chr14 190205 190293      -
             gene_id part_number        transcripts
1 ENSRNOG00000050954         001 ENSRNOT00000073973
2 ENSRNOG00000050954         002 ENSRNOT00000073973
3 ENSRNOG00000050954         003 ENSRNOT00000073973
4 ENSRNOG00000050954         004 ENSRNOT00000073973
5 ENSRNOG00000050954         005 ENSRNOT00000073973
6 ENSRNOG00000050954         006 ENSRNOT00000073973
> 
> 
> 
> cleanEx()
> nameEx("readJunctionSeqCounts")
> ### * readJunctionSeqCounts
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: readJunctionSeqCounts
> ### Title: Read junctionSeq count files
> ### Aliases: readJunctionSeqCounts
> 
> ### ** Examples
> 
> ########################################
> #Set up example data:
> decoder.file <- system.file("extdata/annoFiles/decoder.bySample.txt",package="JctSeqExData2");
> decoder <- read.table(decoder.file,
+                       header=TRUE,
+                       stringsAsFactors=FALSE);
> gff.file <- system.file("extdata/cts/withNovel.forJunctionSeq.gff.gz",package="JctSeqExData2");
> countFiles <- system.file(paste0("extdata/cts/",
+                  decoder$sample.ID,
+                  "/QC.spliceJunctionAndExonCounts.withNovel.forJunctionSeq.txt.gz"),
+                  package="JctSeqExData2");
> ########################################
> #Advanced Analysis:
> 
> #Make a "design" dataframe:
> design <- data.frame(condition = factor(decoder$group.ID));
> #Read the QoRTs counts.
> jscs = readJunctionSeqCounts(countfiles = countFiles,
+            samplenames = decoder$sample.ID,
+            design = design,
+            flat.gff.file = gff.file
+ );
-> STARTING readJunctionSeqCounts (Wed Nov 18 17:29:08 2015)
---> RJSC: samplenames: SAMP1,SAMP2,SAMP3,SAMP4,SAMP5,SAMP6
---> RJSC: flat.gff.file: C:/Users/hartleys/Documents/R/win-library/3.2/JctSeqExData2/extdata/cts/withNovel.forJunctionSeq.gff.gz
---> RJSC: use.exons:TRUE
---> RJSC: use.junctions:TRUE
---> RJSC: use.novel.junctions:TRUE
---> File read complete.
---> Extracted counts. Found 16167 features so far.
---> Extracted gene-level counts. Found: 1053 genes and aggregate-genes.
---> Removed gene features. Found: 15114 features to be included so far.
---> Note: 256 counting bins are from 256 multigene aggregates (ie. overlapping genes).
---> Removed multigene-aggregate features. Found: 14858 features to be included so far.
---> Final feature count: 14858 features to be included in the analysis.
---> Extracted feature counts.
---> counts complete.
-----> reading annotation...
-----> formatting annotation...
-----> initial generation...
-----> creating jscs...
-----> generating count vectors... (Wed Nov 18 17:29:10 2015)
    getAllJunctionSeqCountVectors: dim(counts) = 14858,6 (Wed Nov 18 17:29:10 2015)
    getAllJunctionSeqCountVectors: dim(gct) = 1053,6
    getAllJunctionSeqCountVectors: out generated. dim = 14858,12 (Wed Nov 18 17:29:10 2015)
-----> count vectors generated (Wed Nov 18 17:29:10 2015)
-----> generating DESeqDataSet... (Wed Nov 18 17:29:10 2015)
-----> DESeqDataSet generated (Wed Nov 18 17:29:10 2015)
> 
> 
> 
> 
> cleanEx()
> nameEx("runJunctionSeqAnalyses")
> ### * runJunctionSeqAnalyses
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: runJunctionSeqAnalyses
> ### Title: Run a JunctionSeq analysis.
> ### Aliases: runJunctionSeqAnalyses
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ########################################
> ##D #Set up example data:
> ##D decoder.file <- system.file("extdata/annoFiles/decoder.bySample.txt",package="JctSeqExData2");
> ##D decoder <- read.table(decoder.file,
> ##D                       header=T,
> ##D                       stringsAsFactors=F);
> ##D gff.file <- system.file("extdata/cts/withNovel.forJunctionSeq.gff.gz",package="JctSeqExData2");
> ##D countFiles <- system.file(paste0("extdata/cts/",
> ##D                  decoder$sample.ID,
> ##D                  "/QC.spliceJunctionAndExonCounts.withNovel.forJunctionSeq.txt.gz"),
> ##D                  package="JctSeqExData2");
> ##D ########################################
> ##D 
> ##D jscs <- runJunctionSeqAnalyses(sample.files = countFiles,
> ##D            sample.names = decoder$sample.ID,
> ##D            condition=factor(decoder$group.ID),
> ##D            flat.gff.file = gff.file,
> ##D            analysis.type = "junctionsAndExons"
> ##D );
> ##D 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("testForDiffUsage")
> ### * testForDiffUsage
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: testForDiffUsage
> ### Title: Test Junctions for Differential Junction Usage
> ### Aliases: testForDiffUsage
> 
> ### ** Examples
> 
> data(exampleDataSet,package="JctSeqExData2");
> jscs <- testForDiffUsage(jscs);
Warning in MulticoreParam(workers = nCores) :
  MulticoreParam not supported on Windows. Use SnowParam instead.
-------> testJunctionsForDiffUsage: Starting hypothesis test iteration. (Wed Nov 18 17:29:10 2015)
using supplied model matrix
found results columns, replacing these
-------> testJunctionsForDiffUsage: Finished hypothesis test iteration. (Wed Nov 18 17:29:10 2015)
-------> testJunctionsForDiffUsage: Finished compiling hypothesis test results. (Wed Nov 18 17:29:10 2015)
---> tJfDU(): No non-NA maxCooks values. Ignoring cooks.
> Performing final p.adjust filtering.
>      No cook's cutoffs found.
>      Automatically selecting a filtering threshold of 0.113670218253199 to optimize results at the alpha < 0.01 significance level.
>         (Filtering 0 out of 482 "testable" features, using baseMean < 0.113670218253199)
>         (Rejected H0 for 13 out of 482 features at alpha < 0.01)
> Final p.adjust filtering complete.
> 
> ## Not run: 
> ##D ########################################
> ##D #Set up example data:
> ##D decoder.file <- system.file("extdata/annoFiles/decoder.bySample.txt",package="JctSeqExData2");
> ##D decoder <- read.table(decoder.file,
> ##D                       header=T,
> ##D                       stringsAsFactors=F);
> ##D gff.file <- system.file("extdata/cts/withNovel.forJunctionSeq.gff.gz",package="JctSeqExData2");
> ##D countFiles <- system.file(paste0("extdata/cts/",
> ##D                  decoder$sample.ID,
> ##D                  "/QC.spliceJunctionAndExonCounts.withNovel.forJunctionSeq.txt.gz"),
> ##D                  package="JctSeqExData2");
> ##D ########################################
> ##D #Advanced Analysis:
> ##D 
> ##D #Make a "design" dataframe:
> ##D design <- data.frame(condition = factor(decoder$group.ID));
> ##D #Read the QoRTs counts.
> ##D jscs = readJunctionSeqCounts(countfiles = countFiles,
> ##D            samplenames = decoder$sample.ID,
> ##D            design = design,
> ##D            flat.gff.file = gff.file
> ##D );
> ##D #Generate the size factors and load them into the JunctionSeqCountSet:
> ##D jscs <- estimateJunctionSeqSizeFactors(jscs);
> ##D #Estimate feature-specific dispersions:
> ##D jscs <- estimateJunctionSeqDispersions(jscs);
> ##D #Fit dispersion function and estimate MAP dispersion:
> ##D jscs <- fitJunctionSeqDispersionFunction(jscs);
> ##D #Test for differential usage:
> ##D jscs <- testForDiffUsage(jscs);
> ##D #Estimate effect sizes and expression estimates:
> ##D jscs <- estimateEffectSizes( jscs);
> ##D 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("writeBedTrack")
> ### * writeBedTrack
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: writeBedTrack
> ### Title: Write splice junction browser tracks
> ### Aliases: writeExprBedTrack writeSigBedTrack
> 
> ### ** Examples
> 
> data(exampleDataSet,package="JctSeqExData2");
> writeExprBedTrack("test.exonCoverage.bed.gz", jscs, 
+                   plot.exons = TRUE, plot.junctions = FALSE)
> 
> ## Not run: 
> ##D ########################################
> ##D #Set up example data:
> ##D decoder.file <- system.file("extdata/annoFiles/decoder.bySample.txt",package="JctSeqExData2");
> ##D decoder <- read.table(decoder.file,
> ##D                       header=T,
> ##D                       stringsAsFactors=F);
> ##D gff.file <- system.file("extdata/cts/withNovel.forJunctionSeq.gff.gz",package="JctSeqExData2");
> ##D countFiles <- system.file(paste0("extdata/cts/",
> ##D                  decoder$sample.ID,
> ##D                  "/QC.spliceJunctionAndExonCounts.withNovel.forJunctionSeq.txt.gz"),
> ##D                  package="JctSeqExData2");
> ##D ######################
> ##D #Run example analysis:
> ##D jscs <- runJunctionSeqAnalyses(sample.files = countFiles,
> ##D            sample.names = decoder$sample.ID,
> ##D            condition=factor(decoder$group.ID),
> ##D            flat.gff.file = gff.file,
> ##D            analysis.type = "junctionsAndExons"
> ##D );
> ##D ########################################
> ##D 
> ##D #Exon coverage:
> ##D writeExprBedTrack("test.exonCoverage.bed.gz", jscs, 
> ##D                   plot.exons = TRUE, plot.junctions = FALSE)
> ##D #Junction coverage:
> ##D writeExprBedTrack("test.jctCoverage.bed.gz", jscs, 
> ##D                   plot.exons = FALSE, plot.junctions = TRUE)
> ##D #Both Exon and Junction coverage:
> ##D writeExprBedTrack("test.featureCoverage.bed.gz", jscs)
> ##D 
> ##D #p-values of significant features:
> ##D writeSigBedTrack("test.pvals.bed.gz", jscs)
> ##D 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("writeCompleteResults")
> ### * writeCompleteResults
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: writeCompleteResults
> ### Title: Produce output data files, given annotation files and DEXSeq
> ###   exonCountSet object and DEXSeq results data.
> ### Aliases: writeCompleteResults
> 
> ### ** Examples
> 
> data(exampleDataSet,package="JctSeqExData2");
> #Write results tables and browser track files:
> writeCompleteResults(jscs, outfile.prefix = "./results.");
> STARTING writeCompleteResults (Wed Nov 18 17:29:11 2015)
> wcr: outfile.prefix:  ./results.
> wcr: FDR.threshold:  0.05
> wcr: save.allGenes:  TRUE
> wcr: save.sigGenes:  TRUE
> wcr: save.fit:  FALSE
> wcr: save.VST:  FALSE
> wcr: bedtrack.format:  BED
> wcr: Writing sizeFactors.
> wcr: Writing results for 117 genes.
> wcr:     Found 1516 counting bins belonging to these genes.
> wcr: Writing results for 8 genes with 1 or more significant junctions (at adjusted-p-value threshold 0.05)
> wcr:     Found 226 counting bins belonging to those genes.
> DONE writeCompleteResults (Wed Nov 18 17:29:11 2015)
> 
> ## Not run: 
> ##D ########################################
> ##D #Set up example data:
> ##D decoder.file <- system.file("extdata/annoFiles/decoder.bySample.txt",package="JctSeqExData2");
> ##D decoder <- read.table(decoder.file,
> ##D                       header=T,
> ##D                       stringsAsFactors=F);
> ##D gff.file <- system.file("extdata/cts/withNovel.forJunctionSeq.gff.gz",package="JctSeqExData2");
> ##D countFiles <- system.file(paste0("extdata/cts/",
> ##D                  decoder$sample.ID,
> ##D                  "/QC.spliceJunctionAndExonCounts.withNovel.forJunctionSeq.txt.gz"),
> ##D                  package="JctSeqExData2");
> ##D ######################
> ##D #Run example analysis:
> ##D jscs <- runJunctionSeqAnalyses(sample.files = countFiles,
> ##D            sample.names = decoder$sample.ID,
> ##D            condition=factor(decoder$group.ID),
> ##D            flat.gff.file = gff.file,
> ##D            analysis.type = "junctionsAndExons"
> ##D );
> ##D ########################################
> ##D 
> ##D #Write results tables and browser track files:
> ##D writeCompleteResults(jscs, outfile.prefix = "./results.");
> ##D 
> ## End(Not run)
> 
> 
> 
> ### * <FOOTER>
> ###
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  19.57 46.77 66.62 NA NA 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
