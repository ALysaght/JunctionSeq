\name{readJunctionSeqCounts}
\docType{methods}
\alias{readJunctionSeqCounts}
\title{
   Read junctionSeq count files
}
\description{
   This function loads read-count data (usually produced by QoRTs) and 
   compiles them into a \code{JunctionSeqCountSet} object.
   
   This function is called internally by the \code{\link{runJunctionSeqAnalyses}} 
   function, and thus for most purposes users should not need to call this
   function directly. It may be useful to advanced users performing non-standard
   analyses.
}
\usage{
readJunctionSeqCounts(countfiles, countdata,
                      samplenames, design, 
                      flat.gff.file, 
                      analysis.type = c("junctionsAndExons","junctionsOnly","exonsOnly"),
                      nCores = 1,
                      use.exons, use.junctions, 
                      use.novel.junctions = TRUE, 
                      verbose = TRUE)
}

\arguments{
  \item{countfiles}{
    Character vector. The filenames of the count files generated by QoRTs. The counts must all
    be generated using equivalent QoRTs parameters. The strandedness must be the same, as well
    as the inclusion of novel junctions.
  }
  \item{countdata}{
    List. An alternative parameterization. Instead of supplying count files using the 
    countfiles parameter, you can pass a list of data frames, one for each sample. 
    Each data frame should contain two columns: the first should be the feature id 
    and the second should be the counts. This list must have the same length as 
    the samplenames parameter.
  }
  
  \item{samplenames}{
    Character vector. A vector of full sample names, in the same order as the countfiles parameter. 
  }
  \item{design}{
    A data frame containing the condition variable and all desired covariates. All variables should be
    factors.
  }

  \item{flat.gff.file}{
    Character string. The filename of the "flat" gff annotation file. Can be gzip-compressed. 
    This "flat" gff file must be produced by the QoRTs jar utility using the makeFlatGtf or 
    mergeNovelSplices functions (depending on whether inclusion of novel splice junctions is desired).
    
    NOTE: This option is technically optional, but strongly recommended. If it is not included, then 
    attempts to plot the results will crash unless (non-default) options are used to deactivate the 
    plotting of genomic coordinates and transcript information
  }
  \item{analysis.type}{
    Character string. One of "junctionsAndExons", "junctionsOnly", or "exonsOnly". This parameter determines 
    what type of analysis is to be performed. By default JunctionSeq tests both splice junction 
    loci and exonic regions for differential usage (a "hybrid" analysis). This parameter
    can be used to limit analyses specifically to either splice junction loci or exonic regions.
  }
  \item{nCores}{
    The number of cores to use. Note that multicore functionality may not be available on all platforms.
  }

  \item{use.exons}{
    Logical value. This is an alternate parameterization of the \code{analysis.type} parameter. 
    If \code{TRUE}, then exonic region loci will be included in the analyses and will be tested for 
    differential usage. If this parameter is set, then parameter \code{use.junctions} must also be set.
  }
  \item{use.junctions}{
    Logical value. This is an alternate parameterization of the \code{analysis.type} parameter. 
    If \code{TRUE}, then splice junction loci will be included in the analyses and will be tested for 
    differential usage. If this parameter is set, then parameter \code{use.exons} must also be set.
  }
  \item{use.novel.junctions}{
    Logical value. If \code{TRUE}, then novel splice junctions will not be filtered out prior to analysis.
  }
  \item{verbose}{if TRUE, send debugging and progress messages to the console / stdout.}
}
\value{
  A JunctionSeqCountSet.
}