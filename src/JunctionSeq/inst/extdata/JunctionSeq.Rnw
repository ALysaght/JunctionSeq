%\VignetteIndexEntry{JunctionSeq Vignette}
%\VignettePackage{JunctionSeq}
%\VignetteEngine{knitr::knitr}

\documentclass[12pt]{article}

<<knitr, echo=FALSE, results="hide">>=
library("knitr")
library("Cairo")
opts_chunk$set(tidy=FALSE,dev="CairoPNG",fig.show="hide",
               fig.width=6.5,fig.height=5.5,fig.keep="high",
               message=FALSE)
@

<<style, eval=TRUE, echo=FALSE, results="asis">>=
BiocStyle::latex()
@

\usepackage[sort]{cite}
\usepackage{hyperref}

%------------------------------------------------------------
% newcommands
%------------------------------------------------------------
\newcommand{\myincfigRaw}[3]{%
  \begin{figure}[h]
  \centering
  \includegraphics[width=#2]{figure/#1}
  \caption{\label{figure/#1}#3}
  \label{#1-fig}
  \end{figure}
}

\newcommand{\myincfig}[3]{%
  \begin{figure}[h]
  \centering
  \includegraphics[width=#2]{figure/#1-1}
  \caption{\label{figure/#1}#3}
  \label{#1-fig}
  \end{figure}
}
\newcommand{\myincfigTwo}[3]{%
  \begin{figure}[h]
  \centering
  \includegraphics[width=#2]{figure/#1-1}
  \includegraphics[width=#2]{figure/#1-2}  
  \caption{\label{figure/#1}#3}
  \label{#1-fig}
  \end{figure}
}
\newcommand{\myincfigThree}[3]{%
  \begin{figure}[h]
  \centering
  \includegraphics[width=#2]{figure/#1-1}
  \includegraphics[width=#2]{figure/#1-2}  
  \includegraphics[width=#2]{figure/#1-3}  
  \caption{\label{figure/#1}#3}
  \label{#1-fig}
  \end{figure}
}

\title{JunctionSeq Package User Manual}
\author{Stephen Hartley\\
National Human Genome Research Institute\\
National Institutes of Health}
\date{8 August 2014\\
Revised 8 August 2014\\
v0.0.3}

\begin{document}

\maketitle

\tableofcontents

<<setup,echo=FALSE,results="hide">>=
options(width=80, signif=3, digits=3, prompt=" ", continue=" ")
set.seed(0xdada)
require("JunctionSeq")
require("JctSeqExData")

## To create bitmap versions of plots with many dots, circumventing
##   Sweave's fig=TRUE mechanism...
##   (pdfs are too large)
openBitmap = function(nm, rows=1, cols=1, height = 600, width = 800, cex = 1.2) {
  CairoPNG(paste("QoRT-", nm, ".png", sep=""), 
       width=width*cols, height=height*rows, pointsize=14)
  par(mfrow=c(rows, cols), cex=cex)
}
@ 

%--------------------------------------------------------------------------------
%--------------------------------------------------------------------------------
\section{Overview} \label{sec:praeludium}
%--------------------------------------------------------------------------------
%--------------------------------------------------------------------------------

MORE INFO HERE.

Example citation\cite{DESeq}.

%--------------------------------------------------------------------------------
%--------------------------------------------------------------------------------
\section{Requirements}  \label{sec:reqs}
%--------------------------------------------------------------------------------
%--------------------------------------------------------------------------------

MORE INFO HERE.



%----------
\section{Example Dataset} \label{sec:exdata}
%----------

To allow users to test JunctionSeq and experiment with its functionality, an example dataset is available online (ADD LINK). 

The example dataset was taken from two sets of rat pineal glands harvested at day and at night. Sequence data from six samples are included, three harvested during the day, three at night. To reduce the file sizes to a more managable level, this dataset consists of a small subset taken from the original full set of sequencing runs. First, only the first three sequencing runs were included (out of six runs total). After alignment with RNA-STAR, we extracted only the reads aligning to chromosome 14. This yielded roughly 750,000 reads per sample. The example dataset, including aligned reads, QC data, example scripts, splice junction counts, and JunctionSeq results, is available online (ADD LINK).

Splice junction counts and annotation files generated from this example dataset are included in the \verb|JcnSeqExampleData| R package, available online (ADD LINK), which is what will be used by this vignette. 

The annotation files can be accessed with the commands:
<<GetExampleDataDirectory>>=
decoder.file <- system.file("extdata/annoFiles/decoder.bySample.txt", 
                            package="JctSeqExData", 
                            mustWork=TRUE);
decoder <- read.table(decoder.file,
                      header=T,
                      stringsAsFactors=F);
gff.file <- system.file(
            "extdata/counts/withNovel.forJunctionSeq.gff.gz", 
            package="JctSeqExData", 
            mustWork=TRUE);

print(decoder);
@

The count files can be accessed with the commands:
<<GetCountFiles>>=
countFiles.noNovel <- system.file(paste0("extdata/counts/",
              decoder$sample.ID,
              "/QC.spliceJunctionAndExonCounts.forJunctionSeq.txt.gz"), 
              package="JctSeqExData", mustWork=TRUE);

countFiles <- system.file(paste0("extdata/counts/",
              decoder$sample.ID,
              "/QC.spliceJunctionAndExonCounts.withNovel.forJunctionSeq.txt.gz"), 
              package="JctSeqExData", mustWork=TRUE);

@

%--------------------------------------------------------------------------------
%--------------------------------------------------------------------------------
section{Preparations} \label{sec:prep}
%--------------------------------------------------------------------------------
%--------------------------------------------------------------------------------

ADD MORE INFO HERE.


%----------
\subsection{Alignment} \label{sec:align}
%----------

MORE INFO HERE.


%----------
\subsection{Generating counts via QoRTs} \label{sec:qortsrun}
%----------

To generate splice junction counts, you must run QoRTs on each aligned bam file. For example, to run QoRTs on the first read-group of sample \verb|S_D1| from the example dataset:
\begin{verbatim}
java -jar /path/to/jarfile/QoRTs.jar QC \
                   --stranded \
                   inputData/bamFiles/S_D1_RG1.chr14.bam \
                   inputData/annoFiles/rn4.anno.chr14.gtf.gz \
                   outputData/qortsData/S_D1_RG1/
\end{verbatim}
Note that the \verb|--stranded| option is required because this example dataset is strand-specific. Also note that QoRTs uses the original gtf annotation file, NOT the flattened gff file produced in section \ref{sec:flatAnno}.

Alternatively, if Quality Control is being done seperately by other software packages or collaborators, the splice junction counts can be generated alone by setting the \verb|--runFunctions| option:
\begin{verbatim}
java -jar /path/to/jarfile/QoRTs.jar QC \
 --stranded \
 --runFunction JunctionCalcs,writeKnownSplices,writeNovelSplices,writeSpliceExon \
 inputData/bamFiles/S_D1_RG1.chr14.bam \
 inputData/annoFiles/rn4.anno.chr14.gtf.gz \
 outputData/qortsData/S_D1_RG1/
\end{verbatim}
This will take much less time to run, as it does not perform the full battery of quality control tests.

For more information about the quality control metrics provided by QoRTs, and how to visualize, organize, and view them, see the QoRTs package, available online (ADD LINK!)

%----------
\subsection{Merging Counts From Multiple Runs (If Needed)} \label{sec:mergeCounts}
%----------

To avoid issue of run- or lane-specific artifacts driving false assocation, it is \emph{strongly} recommended that datasets be merged into balanced pooled libraries and run together. However, this may necessitate running such pooled libraries over multiple lanes to achieve the desired read coverage. This means that after demultiplexing, each sample will consist of multiple seperate "technical replicates", from a number of different sequencer lanes/runs.

The example dataset has three such "read groups" per sample, which were aligned separately into three bam files per sample. For the purposes of quality control, QoRTs was run separately on each of these bam files (making it easier to discern any lane or run specific artifacts that might occur). It is then necessary to combine the read counts from each of these bam files.

QoRTs includes an automated utility for performing this merger. For the example dataset, the command would be:
\begin{verbatim}
java -jar /path/to/jarfile/QoRTs.jar \
                mergeAllCounts \
                outputData/qortsData/ \
                inputData/annoFiles/decoder.byUID.txt \
                outputData/countTables/
\end{verbatim}

%----------
\subsubsection{(Option #1) Including Only Annotated Splice Junction Loci)} \label{sec:flatAnno}
%----------

If you wish to only test annotated splice junctions, then a simple flat annotation file can be generated for use by JunctionSeq. This file parses the input gtf annotation and assigns unique identifiers to each feature (exon or splice junction) belonging to each gene. These identifiers will match the identifiers listed in the junction count files produced by QoRTs in the count-generation step (see Section \ref{sec:qortsrun}).

\begin{verbatim}
java -jar /path/to/jarfile/QoRTs.jar makeFlatGtf \
                   --stranded \
                   inputData/annoFiles/rn4.anno.chr14.gtf.gz \
                   outputData/JunctionSeq.flat.gff.gz
\end{verbatim}
Note: it is \emph{vitally important} that the same options and gtf annotation file are used for creating this flat gff file as were used in the count-generation step (described in Section \ref{sec:qortsrun})! If the counts are generated in stranded mode, the gff file must also be generated in stranded mode.

%----------
\subsubsection{(Option #2) Including Novel Splice Junction Loci} \label{sec:novelCounts}
%----------

One of the core advantages of JunctionSeq over similar tools such as DEXSeq is the ability to include novel (ie. unannotated) splice junctions. Most advanced aligners have the ability to align read-pairs to both known and unknown splice junctions. However, many of these splice junctions will only have one or two read pairs aligned across them. Many of these putative splice junctions may be artifacts caused by sequencing errors or mapping artifacts, and even if they are real JunctionSeq will not have the power to detect any differential splice junction usage across them. Therefore, it is generally desirable to first filter splice junctions by read depth.

In order to properly filter by read depth, size factors are needed. These can be generated in JunctionSeq (see section ADD REFERENCE), or generated from gene-level read counts using DESeq2 or edgeR. A full description of how to generate size factor files is contained in the advanced manual that comes with the full example dataset (ADD LINK).

\begin{verbatim}
java -jar /path/to/jarfile/QoRTs.jar QC \
                mergeNovelSplices  \
                --minCount 100 \
                --stranded \
                outputData/countTables/ \
                outputData/sizeFactors.GEO.txt \
                inputData/annoFiles/rn4.anno.chr14.gtf.gz \
                outputData/countTables/
\end{verbatim}
This utility finds all splice junctions that fall inside the bounds of any known gene. It then filters this set of splice junctions, selecting only the junctions loci with mean normalized read-pair counts of greater than 100 read-pairs. It then gives each splice junction that passes filter a unique identifier.

This utility has two combined functions: first it writes a .gff file containing the unique identifiers for each annotated and passed-filter-unannotated splice junction. Secondly, for each sample it produces a merged splice junction count file listing the splice junction counts for each of these uniquely identified splice junctions.

%--------------------------------------------------------------------------------
%--------------------------------------------------------------------------------
\section{JunctionSeq Analysis} \label{sec:workflow}
%--------------------------------------------------------------------------------
%--------------------------------------------------------------------------------

Once read counts have been generated.
MORE INFO HERE

%----------
\subsection{Testing for differential splice junction usage} \label{sec:DJUtest}
%----------

MORE INFO HERE.

%
<<testForDJU, results="hide">>=
ecs <- runJunctionSeqAnalyses(sample.files = countFiles,
                           sample.names = decoder$sample.ID, 
                           condition=factor(decoder$group.ID),
                           annofile = gff.file,
                           use.novel.splice.sites = TRUE
                           );
@

%----------
\subsection{Extracting results} \label{sec:getres}
%----------

MORE INFO HERE.

%
<<makeRes, results="hide">>=
complete.res <- generateCompleteResults(ecs, outfile.prefix="./test");
@

%--------------------------------------------------------------------------------
%--------------------------------------------------------------------------------
\section{Visualization} \label{sec:vis}
%--------------------------------------------------------------------------------
%--------------------------------------------------------------------------------

MORE INFO HERE.

%----------
\subsection{Summary Plots} \label{sec:summaryPlots}
%----------

MORE INFO HERE.

<<summaryplots, results="hide", fig.width=6.5, fig.height=5.5>>=
plotDispEsts(ecs);
plotMA(complete.res, FDR=0.05, ylim = c(-5,5), cex=0.8);
@

Which produces the plots:

\myincfigTwo{summaryplots}{0.45\textwidth}{Summary Plots}

%----------
\subsection{Gene plots} \label{sec:allPlot}
%----------

MORE INFO HERE.

%
<<makeAllPlots>>=
buildAllPlots(complete.res,
              ecs=ecs,
              anno.file=gff.file,
              outfile.prefix = "./test",
              use.plotting.device = "png")
@

\pagebreak
%----------
\subsubsection{Predicted Expression} \label{sec:subplot1}
%----------

Figure \ref{../test5-ENSRNOG00000009281-expr-fig} shows MORE INFO HERE.
\myincfigRaw{../test5-ENSRNOG00000009281-expr}{0.85\textwidth}{Predicted Expression}

\pagebreak
%----------
\subsubsection{Relative Expression} \label{sec:subplot2}
%----------

Figure \ref{../test5-ENSRNOG00000009281-rExpr-fig} shows MORE INFO HERE.
\myincfigRaw{../test5-ENSRNOG00000009281-rExpr}{0.85\textwidth}{Relative Expression}

\pagebreak
%----------
\subsubsection{Log Raw Counts} \label{sec:subplot3}
%----------

Figure \ref{../test5-ENSRNOG00000009281-logRawCounts-fig} shows MORE INFO HERE.
\myincfigRaw{../test5-ENSRNOG00000009281-logRawCounts}{0.85\textwidth}{Log Raw Counts}

\pagebreak
%----------
\subsubsection{Normalized Counts} \label{sec:subplot4}
%----------

Figure \ref{../test5-ENSRNOG00000009281-normCounts-fig} shows MORE INFO HERE.
\myincfigRaw{../test5-ENSRNOG00000009281-normCounts}{0.85\textwidth}{Normalized Counts}

%----------
\subsection{Interpretation} \label{sec:allPlot}
%----------

MORE INFO HERE.

%--------------------------------------------------------------------------------
%--------------------------------------------------------------------------------
\section{(Optional) Generating Genome Browser Tracks} \label{sec:browserFiles}
%--------------------------------------------------------------------------------
%--------------------------------------------------------------------------------

MORE INFO HERE.

%----------
\subsection{Wiggle Tracks} \label{sec:wiggleTracks}
%----------

MORE INFO HERE.

%----------
\subsubsection{Generating Wiggle Tracks} \label{sec:wiggleGen}
%----------

MORE INFO HERE
\begin{verbatim}
java -jar /path/to/jarfile/QoRTs.jar QC \
                bamToWiggle \
                --stranded \
                --windowSize 100 \
                --negativeReverseStrand \
                --includeTrackDefLine \
                --rgbColor 0,0,0 \
                inputData/bamFiles/S_D1_RG1.chr14.bam \
                S_D1_RG1 \
                inputData/annoFiles/rn4.chr14.chrom.sizes \
                outputData/qortsData/S_D1_RG1/QC.wiggle
\end{verbatim}

%----------
\subsubsection{Merging Wiggle Tracks} \label{sec:wiggleMerge}
%----------

MORE INFO HERE

%----------
\subsection{Splice Junction Tracks} \label{sec:junctionTracks}
%----------

MORE INFO HERE.

%----------
\subsubsection{Generating Splice Junction Tracks} \label{sec:junctionTrackGen}
%----------

More Info Here.

%----------
\subsubsection{Merging Splice Junction Tracks} \label{sec:junctionTrackMerge}
%----------

More Info Here.

%--------------------------------------------------------------------------------
%--------------------------------------------------------------------------------
\section{References} \label{sec:references}
%--------------------------------------------------------------------------------
%--------------------------------------------------------------------------------
\begingroup
\renewcommand{\section}[2]{}%
\bibliography{JunctionSeq}
\endgroup

%--------------------------------------------------------------------------------
%--------------------------------------------------------------------------------
\section{Session Information} \label{sec:sessioninfo}
%--------------------------------------------------------------------------------
%--------------------------------------------------------------------------------

The session information records the versions of all the packages used in the generation of the present document.

<<sessionInfo>>=
sessionInfo()
@

%--------------------------------------------------------------------------------
%--------------------------------------------------------------------------------
\section{Legal} \label{sec:legal}
%--------------------------------------------------------------------------------
%--------------------------------------------------------------------------------

This software is an improvement and expansion of DEXSeq,
which is licensed under the GPL v3.

The portions of this software that are NOT part of the DEXSeq 
package are "United States Government Work" under the terms 
of the United States Copyright Act.  It was written as part of 
the authors' official duties for the United States Government and 
thus cannot be copyrighted.  This software is freely available to
the public for use without a copyright notice.  Restrictions 
cannot be placed on its present or future use.

Although all reasonable efforts have been taken to ensure the 
accuracy and reliability of the software and data, the National 
Human Genome Research Institute (NHGRI) and the U.S. Government 
does not and cannot warrant the performance or results that may 
be obtained by using this software or data.  NHGRI and the U.S. 
Government disclaims all warranties as to performance, 
merchantability or fitness for any particular purpose.

The DEXSeq package and all parts of this package that 
are not United States Government Work, are licensed under the 
GPL v3:

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

NOTE: The QoRTs Scala package (which is not included with this package
but is mentioned in this vignette) includes (internally) the sam-JDK 
library (sam-1.113.jar), from picard tools, which is licensed 
under the MIT license.
The MIT license and copyright information can be accessed using the command:
\begin{verbatim}
java -jar /path/to/jarfile/QoRTs.jar ? samjdkinfo
\end{verbatim}

\end{document}
