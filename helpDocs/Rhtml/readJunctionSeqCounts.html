<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>R: Read junctionSeq count files</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="R.css">
</head><body>

<table width="100%" summary="page for readJunctionSeqCounts {JunctionSeq}"><tr><td>readJunctionSeqCounts {JunctionSeq}</td><td align="right">R Documentation</td></tr></table>

<h2>
Read junctionSeq count files
</h2>

<h3>Description</h3>

<p>This function reads count data (usually produced by QoRTs) and 
compiles them into a <code>JunctionSeqCountSet</code>.
</p>
<p>For most purposes this function should not be needed, but might 
be useful to advanced users performing non-standard analyses. 
This and all other standard analysis functions can be run 
automatically via the <code><a href="runJunctionSeqAnalyses.html">runJunctionSeqAnalyses</a></code> 
function.
</p>


<h3>Usage</h3>

<pre>
readJunctionSeqCounts(countfiles, 
                      countdata,
                      samplenames,
                      design, 
                      flat.gff.file, 
                      use.splice.sites = TRUE, 
                      use.novel.splice.sites = TRUE, 
                      use.exons = FALSE, 
                      verbose = TRUE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>countfiles</code></td>
<td>

<p>Character vector. The filenames of the count files generated by QoRTs. The counts must all
be generated using equivalent QoRTs parameters. The strandedness must be the same, as well
as the inclusion of novel junctions.
</p>
</td></tr>
<tr valign="top"><td><code>countdata</code></td>
<td>

<p>List. An alternative parameterization. Instead of supplying count files using the 
countfiles parameter, you can pass a list of data frames, one for each sample. 
Each data frame should contain two columns: the first should be the feature id 
and the second should be the counts. This list must have the same length as 
the samplenames parameter.
</p>
</td></tr>
<tr valign="top"><td><code>samplenames</code></td>
<td>

<p>Character vector. A vector of full sample names, in the same order as the countfiles parameter. 
</p>
</td></tr>
<tr valign="top"><td><code>design</code></td>
<td>

<p>A data frame containing the condition variable and all desired covariates. All variables should be
factors.
</p>
</td></tr>
<tr valign="top"><td><code>flat.gff.file</code></td>
<td>

<p>Character string. The filename of the &quot;flat&quot; gff annotation file. Can be gzip-compressed. 
This &quot;flat&quot; gff file must be produced by the QoRTs jar utility using the makeFlatGtf or 
mergeNovelSplices functions (depending on whether inclusion of novel splice junctions is desired).
</p>
<p>NOTE: This option is technically optional, but strongly recommended. If it is not included, then 
attempts to plot the results will crash unless (non-default) options are used to deactivate the 
plotting of genomic coordinates and transcript information
</p>
</td></tr>
<tr valign="top"><td><code>use.splice.sites</code></td>
<td>

<p>FOR ADVANCED USERS ONLY: Logical value. If <code>TRUE</code>, splice junctions will be included in the analyses.
</p>
</td></tr>
<tr valign="top"><td><code>use.novel.splice.sites</code></td>
<td>

<p>Logical value. If <code>TRUE</code>, splice junctions that are marked as novel in the gff annotation will be included in the analysis.
Note that this is does nothing if there are no novel splice junctions in the count tables. 
</p>
</td></tr>
<tr valign="top"><td><code>use.exons</code></td>
<td>

<p>FOR ADVANCED USERS ONLY: Logical value. If <code>TRUE</code>, exon segments will be included in the analyses.
</p>
</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>
<p>if TRUE, send debugging and progress messages to the console / stdout.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A JunctionSeqCountSet.
</p>

<hr><div align="center">[Package <em>JunctionSeq</em> version 0.3.5 <a href="00Index.html">Index</a>]</div>
</body></html>
